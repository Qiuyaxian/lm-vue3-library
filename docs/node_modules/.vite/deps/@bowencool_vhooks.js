import {
  computed,
  getCurrentScope,
  isRef,
  onMounted,
  onScopeDispose,
  reactive,
  readonly,
  ref,
  unref,
  watch
} from "./chunk-5NCCIKTV.js";

// ../node_modules/.pnpm/@bowencool+async-utilities@2.5.4/node_modules/@bowencool/async-utilities/es/debounceAsyncResult/index.js
function debounceAsyncResult(fn) {
  let lastFetchId = 0;
  return function asyncDebounced() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const fetchId = ++lastFetchId;
    return new Promise((resolve, reject) => {
      fn.call(this, ...args).then(function() {
        if (fetchId === lastFetchId) {
          resolve(...arguments);
        }
      }).catch(function() {
        if (fetchId === lastFetchId) {
          reject(...arguments);
        }
      });
    });
  };
}

// ../node_modules/.pnpm/@bowencool+async-utilities@2.5.4/node_modules/@bowencool/async-utilities/es/debounceAsync/index.js
function debounceAsync(fn, ms) {
  if (ms === void 0) {
    ms = 300;
  }
  let timeoutId;
  return function debouncedFiltered() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new Promise((resolve, reject) => {
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        fn.call(this, ...args).then(resolve).catch(reject);
      }, ms);
    });
  };
}

// ../node_modules/.pnpm/@bowencool+async-utilities@2.5.4/node_modules/@bowencool/async-utilities/es/throttleAsyncResult/index.js
function throttleAsyncResult(fn, _temp) {
  let {
    useSamePromise = false
  } = _temp === void 0 ? {} : _temp;
  let isPending = false;
  let theLastPromise = null;
  return function asyncThrottled() {
    if (isPending) {
      if (useSamePromise && theLastPromise) {
        return theLastPromise;
      }
      return new Promise(() => {
      });
    } else {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const ret = fn.call(this, ...args).then(function() {
        isPending = false;
        theLastPromise = null;
        return Promise.resolve(...arguments);
      }).catch(function() {
        isPending = false;
        theLastPromise = null;
        return Promise.reject(...arguments);
      });
      theLastPromise = ret;
      isPending = true;
      return ret;
    }
  };
}

// ../node_modules/.pnpm/@bowencool+async-utilities@2.5.4/node_modules/@bowencool/async-utilities/es/withRetryAsync/index.js
function withRetryAsync(fn, _temp) {
  let {
    /** 最多重试次数 */
    maxCount = 3,
    /**
     * @desc 每次重试之间的等待间隔时间
     */
    retryInterval = 1e3,
    /** 每次重试开始的回调，含第一次，第一次是1 */
    onRetry = (i) => {
    },
    /**
     * @desciption 每次失败的回调
     */
    onFailed = (i, lastFailedReason) => {
    }
  } = _temp === void 0 ? {} : _temp;
  return function withRetryedAsync() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new Promise((resolve, reject) => {
      let retriedCount = 0;
      const that = this;
      execTask();
      function execTask() {
        onRetry(++retriedCount);
        fn.call(that, ...args).then(function() {
          resolve(...arguments);
        }).catch(function() {
          for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            e[_key2] = arguments[_key2];
          }
          if (retriedCount >= maxCount) {
            onFailed(retriedCount, e);
            reject(...e);
          } else {
            onFailed(retriedCount, e);
            setTimeout(execTask, retryInterval);
          }
        });
      }
    });
  };
}

// ../node_modules/.pnpm/@bowencool+async-utilities@2.5.4/node_modules/@bowencool/async-utilities/es/abortableAsync/index.js
var AbortError = class extends Error {
};
AbortError.prototype.name = "AbortError";
var TimeoutError = class extends Error {
};
TimeoutError.prototype.name = "TimeoutError";
function abortableAsync(fn, opt) {
  if (opt === void 0) {
    opt = {};
  }
  return function abortabledAsync() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new Promise((resolve, reject) => {
      var _opt$signal;
      let timer;
      let aborted = false;
      function doAbort() {
        if (!opt.alwaysPendingWhenAborted) {
          reject(new AbortError("aborted"));
        }
        aborted = true;
        clearEffect();
      }
      (_opt$signal = opt.signal) == null ? void 0 : _opt$signal.addEventListener == null ? void 0 : _opt$signal.addEventListener("abort", doAbort);
      function doTimeout() {
        if (!opt.alwaysPendingWhenAborted) {
          reject(new TimeoutError(`timeout of ${opt.timeout}ms`));
        }
        aborted = true;
        clearEffect();
      }
      if (typeof opt.timeout === "number" && opt.timeout > 0) {
        timer = setTimeout(doTimeout, opt.timeout);
      }
      function clearEffect() {
        var _opt$signal2;
        if (typeof timer !== "undefined") {
          clearTimeout(timer);
          timer = void 0;
        }
        (_opt$signal2 = opt.signal) == null ? void 0 : _opt$signal2.removeEventListener == null ? void 0 : _opt$signal2.removeEventListener("abort", doAbort);
      }
      fn.call(this, ...args).then(function() {
        if (!aborted) {
          resolve(...arguments);
        }
        clearEffect();
      }).catch(function() {
        if (!aborted) {
          reject(...arguments);
        }
        clearEffect();
      });
    });
  };
}

// ../node_modules/.pnpm/@vueuse+shared@7.7.1_vue@3.4.26/node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
var isClient = typeof window !== "undefined";
var isString = (val) => typeof val === "string";
var noop = () => {
};
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let preventLeading = !leading;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = unref(ms);
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration) {
      lastExec = Date.now();
      if (preventLeading)
        preventLeading = false;
      else
        invoke();
    }
    if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        if (!leading)
          preventLeading = true;
        clear();
        invoke();
      }, duration);
    }
    if (!leading && !timer)
      timer = setTimeout(() => preventLeading = true, duration);
  };
  return filter;
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}
function useDebounce(value, ms = 200, options = {}) {
  if (ms <= 0)
    return value;
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}
function useThrottleFn(fn, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (interval <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, unref(interval));
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval)) {
    const stopWatch = watch(interval, () => {
      if (immediate && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start,
    stop
  };
}

// ../node_modules/.pnpm/@vueuse+core@7.7.1_vue@3.4.26/node_modules/@vueuse/core/index.mjs
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var SwipeDirection = ((SwipeDirection2) => {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
  return SwipeDirection2;
})(SwipeDirection || {});
var _a;
var _b;
var isIOS = isClient && (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var initialRect = {
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 0,
  width: 0
};
var initialState = __spreadValues$3({
  text: ""
}, initialRect);

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-async-state/index.js
function useAsyncState(service, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    manual = false,
    defaultParams,
    onSuccess,
    onError,
    onComplete,
    pollingInterval = 0,
    pollingWhenHidden = true,
    refreshOnWindowFocus = false,
    focusTimespan = 5e3,
    loadingDelay = 0,
    debounceInterval = 0,
    timeout = 0,
    debounceResult = false,
    throttleResult = false,
    autoRetry
  } = options;
  const data = ref();
  const params = ref();
  const error = ref();
  const pending = ref(false);
  const loading = useDebounce(pending, loadingDelay);
  let controller;
  if (autoRetry) {
    service = withRetryAsync(service, autoRetry);
  }
  if (debounceResult) {
    service = debounceAsyncResult(service);
  }
  let run = async function _run() {
    for (var _len = arguments.length, _params = new Array(_len), _key = 0; _key < _len; _key++) {
      _params[_key] = arguments[_key];
    }
    try {
      var _controller;
      pending.value = true;
      if (typeof AbortController !== "undefined") {
        controller = new AbortController();
      }
      const rez = await abortableAsync(service, {
        timeout,
        signal: (_controller = controller) == null ? void 0 : _controller.signal
      })(..._params);
      data.value = rez;
      error.value = void 0;
      onSuccess == null ? void 0 : onSuccess(rez, _params);
      return rez;
    } catch (err) {
      data.value = void 0;
      error.value = err;
      onError == null ? void 0 : onError(err, _params);
      throw err;
    } finally {
      pending.value = false;
      onComplete == null ? void 0 : onComplete(_params);
      params.value = _params;
    }
  };
  if (typeof debounceInterval === "number" && debounceInterval > 0) {
    run = debounceAsync(run, debounceInterval);
  } else if (throttleResult && !debounceResult) {
    run = throttleAsyncResult(run, typeof throttleResult === "object" ? throttleResult : void 0);
  }
  function _runWithDefaultParams() {
    if (pending.value) return;
    const _params = params.value || defaultParams || [];
    run(..._params);
  }
  let pause;
  let resume;
  if (typeof pollingInterval === "number" && pollingInterval > 0) {
    const pausable = useIntervalFn(_runWithDefaultParams, pollingInterval, {
      immediate: !manual,
      immediateCallback: true
    });
    pause = pausable.pause;
    resume = pausable.resume;
  } else if (!manual) {
    _runWithDefaultParams();
  }
  if (refreshOnWindowFocus) {
    const onWindowFoucs = useThrottleFn(_runWithDefaultParams, focusTimespan, false);
    useEventListener(window, "focus", onWindowFoucs);
  }
  if (!pollingWhenHidden) {
    useEventListener(document, "visibilitychange", () => {
      const visibility = document.visibilityState;
      if (visibility === "hidden") {
        pause == null ? void 0 : pause();
      } else {
        resume == null ? void 0 : resume();
      }
    });
  }
  return {
    params,
    data,
    loading,
    pending: readonly(pending),
    error: readonly(error),
    run,
    pause,
    resume,
    cancel() {
      var _controller2;
      pause == null ? void 0 : pause();
      (_controller2 = controller) == null ? void 0 : _controller2.abort();
    }
  };
}

// ../node_modules/.pnpm/copy-rich-text@0.2.1/node_modules/copy-rich-text/es/copy.js
async function copy(textOrElement, options) {
  let dom;
  if (typeof textOrElement === "number") {
    textOrElement = String(textOrElement);
  }
  if (typeof textOrElement === "string") {
    dom = document.createElement("div");
    if (options == null ? void 0 : options.html) {
      dom.innerText = textOrElement;
    } else {
      dom.innerHTML = textOrElement;
    }
  } else if (textOrElement instanceof HTMLElement) {
    if (options == null ? void 0 : options.html) {
      return copy(textOrElement.innerHTML, options);
    }
    dom = textOrElement.cloneNode(true);
  } else {
    console.error("legacyCopy \u53C2\u6570\u9519\u8BEF", textOrElement);
    throw new Error(`First params must be string or HTMLElement, but got ${Object.prototype.toString.call(textOrElement).slice(8, -1)}`);
  }
  dom.style.whiteSpace = "pre";
  dom.style.left = "-9999px";
  dom.style.position = "fixed";
  document.body.appendChild(dom);
  await copyDomContent(dom);
  document.body.removeChild(dom);
}
async function copyDomContent(dom) {
  var _a2;
  const text = select(dom);
  if (typeof document.execCommand === "function") {
    document.execCommand("copy");
  } else if (navigator.clipboard) {
    await navigator.clipboard.writeText(text);
  }
  (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
}
function select(element) {
  let selectedText;
  if (element instanceof HTMLSelectElement) {
    element.focus();
    selectedText = element.value;
  } else if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
    const isReadOnly = element.hasAttribute("readonly");
    if (!isReadOnly) {
      element.setAttribute("readonly", "");
    }
    element.select();
    element.setSelectionRange(0, element.value.length);
    if (!isReadOnly) {
      element.removeAttribute("readonly");
    }
    selectedText = element.value;
  } else {
    if (element.hasAttribute("contenteditable")) {
      element.focus();
    }
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(element);
    if (!selection) {
      throw new Error("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u9009\u62E9");
    }
    selection.removeAllRanges();
    selection.addRange(range);
    selectedText = selection.toString();
  }
  return selectedText;
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-copy/index.js
function useCopy(_ref) {
  let {
    text,
    duration = 1e3,
    onSuccess,
    onError,
    ...copyOptions
  } = _ref;
  const copied = ref(false);
  const error = ref();
  const timeout = useTimeoutFn(() => {
    copied.value = false;
    error.value = null;
  }, duration);
  return {
    error,
    copied,
    copy(options) {
      if (copied.value) return;
      const textOrElement = unref(text);
      copy(textOrElement, {
        ...copyOptions,
        ...options
      }).then(() => {
        copied.value = true;
        onSuccess == null ? void 0 : onSuccess();
        timeout.start();
      }).catch((err) => {
        error.value = err;
        onError == null ? void 0 : onError(err);
        timeout.start();
        throw err;
      });
    }
  };
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-count-down/functions.js
function calculateDuration(time, format) {
  if (format === void 0) {
    format = "DD:HH:mm:ss";
  }
  const ret = {};
  const scannedTimes = Object.values(time);
  const scannedFormats = ["D", "H", "m", "s"];
  const padValues = [24, 60, 60, 1e3];
  scannedFormats.forEach((scannedFormat, index) => {
    if (!format.includes(scannedFormat)) {
      scannedTimes[index + 1] += scannedTimes[index] * padValues[index];
    } else {
      ret[scannedFormat] = scannedTimes[index];
    }
  });
  if (format.includes("S")) {
    const ms = scannedTimes[scannedTimes.length - 1];
    ret.S = ms;
  }
  return ret;
}
function formatDuration(time, format) {
  if (format === void 0) {
    format = "DD:HH:mm:ss";
  }
  format = format.replace(/(D|H|m|s)+/g, (rez, key) => `${time[key]}`.padStart(rez.length, "0"));
  format = format.replace(/(S)+/g, (rez, key) => `${time[key]}`.padStart(3, "0").slice(0, rez.length));
  return format;
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-count-down/index.js
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var getDuration = (durationMs) => {
  const days = Math.floor(durationMs / DAY);
  const hours = Math.floor(durationMs % DAY / HOUR);
  const minutes = Math.floor(durationMs % HOUR / MINUTE);
  const seconds = Math.floor(durationMs % MINUTE / SECOND);
  const milliseconds = Math.floor(durationMs % SECOND);
  return {
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  };
};
function useCountDown(props) {
  const {
    format = "DD:HH:mm:ss"
  } = props;
  const enableMilliseconds = /S/.test(format);
  const until2 = ref(0);
  const remain = ref(props.remain || 0);
  const handle = ref(0);
  const running = ref(false);
  const calculated = computed(() => calculateDuration(getDuration(remain.value), format));
  const formattedText = computed(() => formatDuration(calculated.value, format));
  function updateRemain() {
    let remainMs = until2.value ? until2.value - Date.now() : remain.value;
    if (enableMilliseconds) {
      if (remainMs <= 0) remainMs = 0;
      remain.value = remainMs;
    } else {
      remainMs = Math.ceil(remainMs / SECOND) * SECOND;
      if (remainMs <= 0) remainMs = 0;
      remain.value = remainMs;
    }
  }
  function counting() {
    updateRemain();
    if (remain.value <= 0) {
      stop();
      props.onEnd == null ? void 0 : props.onEnd();
      return;
    }
    if (enableMilliseconds) {
      handle.value = window.requestAnimationFrame(counting);
    }
  }
  function resume() {
    if (running.value) return;
    running.value = true;
    until2.value = Date.now() + remain.value;
    if (enableMilliseconds) {
      counting();
    } else {
      handle.value = window.setInterval(counting, SECOND);
    }
  }
  function pause() {
    cancelAnimationFrame(handle.value);
    clearInterval(handle.value);
    running.value = false;
  }
  function stop() {
    pause();
    remain.value = 0;
  }
  function reset() {
    pause();
    remain.value = props.remain || 0;
  }
  tryOnScopeDispose(pause);
  const base = {
    remain,
    running,
    calculated,
    formattedText
  };
  if (!props.manual) {
    resume();
    return base;
  }
  return {
    ...base,
    resume,
    pause,
    reset
  };
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-paging/index.js
function usePaging(pagingService, _temp) {
  let {
    defaultPageSize = 10,
    ...others
  } = _temp === void 0 ? {} : _temp;
  const {
    data,
    error,
    loading,
    run
  } = useAsyncState(pagingService, {
    debounceResult: true,
    debounceInterval: 100,
    ...others,
    manual: true
  });
  const paginationState = reactive({
    total: 0,
    currentPage: 1,
    pageSize: defaultPageSize,
    "onUpdate:currentPage": async function(pageNumber) {
      const {
        pageSize
      } = paginationState;
      const rez = await run({
        pageSize,
        pageNumber,
        offset: pageSize * (pageNumber - 1),
        count: pageSize
      });
      paginationState.currentPage = pageNumber;
      paginationState.pageSize = pageSize;
      paginationState.total = rez.total;
    },
    "onUpdate:pageSize": async function(pageSize) {
      var _a2;
      const rez = await run({
        pageSize,
        pageNumber: 1,
        offset: 0,
        count: pageSize
      });
      paginationState.currentPage = 1;
      paginationState.pageSize = pageSize;
      paginationState.total = (_a2 = rez.total) != null ? _a2 : 0;
    }
  });
  const goPage = (n) => promiseTimeout(0).then(() => paginationState["onUpdate:currentPage"](n));
  onMounted(() => {
    goPage(1);
  });
  return {
    list: computed(() => {
      var _data$value;
      return (_data$value = data.value) == null ? void 0 : _data$value.list;
    }),
    paginationState,
    goPage,
    rawData: data,
    loading,
    error
  };
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/use-infinite-scroll/index.js
function useInfiniteScroll(pagingService, _temp) {
  let {
    defaultPageSize: pageSize = 10,
    isDone,
    ...others
  } = _temp === void 0 ? {} : _temp;
  const refreshing = ref(false);
  const done = ref(false);
  const list = ref();
  const {
    data,
    error,
    loading,
    run
  } = useAsyncState(pagingService, {
    // debounceResult: true, // 这个 data 没有用到，所以不需要
    debounceInterval: 100,
    ...others,
    manual: true
  });
  const state = reactive({
    pageNumber: 1
  });
  const loadData = throttleAsyncResult(async function(isRefresh) {
    if (isRefresh === void 0) {
      isRefresh = false;
    }
    if (done.value && !isRefresh) return;
    const oldList = list.value || [];
    const offset = isRefresh ? 0 : oldList.length;
    if (isRefresh) {
      state.pageNumber = 1;
      refreshing.value = true;
    }
    const payload = {
      pageSize,
      pageNumber: state.pageNumber,
      offset,
      count: pageSize
    };
    console.log(`loadData${isRefresh ? "(refresh)" : ""}`, payload);
    try {
      const res = await run(payload);
      const newList = isRefresh ? res.list : oldList.concat(res.list);
      list.value = newList;
      console.log(`	page ${state.pageNumber}: (${offset}+${res.list.length})/${res.total}`, res);
      const isDoneF = isDone || ((r) => r.list.length < pageSize || newList.length >= r.total);
      done.value = isDoneF(res);
      state.pageNumber += 1;
    } finally {
      refreshing.value = false;
    }
  });
  onMounted(() => {
    loadData();
  });
  return {
    /** 原始响应 */
    rawData: data,
    /** 合并后的列表 */
    list,
    /** 正在刷新第一页的数据 */
    refreshing,
    /** 正在加载下一页的数据 */
    loadingMore: computed(() => loading.value && !refreshing.value),
    /** 正在请求接口 */
    loading,
    /** 接口错误 */
    error,
    /** 加载下一页的数据 */
    loadMore: () => loadData(),
    /** “暂无数据” */
    empty: computed(() => {
      var _list$value;
      return ((_list$value = list.value) == null ? void 0 : _list$value.length) === 0 && !loading.value && done.value;
    }),
    /** 是否已经加载全部 */
    done,
    /** 刷新到第一页 */
    refresh: () => loadData(true)
  };
}

// ../node_modules/.pnpm/@bowencool+vhooks@0.3.2/node_modules/@bowencool/vhooks/es/index.js
var version = "0.3.2";
export {
  calculateDuration,
  formatDuration,
  useAsyncState,
  useCopy,
  useCountDown,
  useInfiniteScroll,
  usePaging,
  version
};
/*! Bundled license information:

@bowencool/async-utilities/es/debounceAsyncResult/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/debounceAsync/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/throttleAsyncResult/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/concurrentAsync/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/withRetryAsync/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/abortableAsync/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/async-utilities/es/index.js:
  (*!
  * @bowencool/async-utilities v2.5.4
  *)

@bowencool/vhooks/es/use-async-state/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/use-copy/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/use-count-down/functions.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/use-count-down/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/use-paging/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/use-infinite-scroll/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)

@bowencool/vhooks/es/index.js:
  (*!
  * @bowencool/vhooks v0.3.2
  *)
*/
//# sourceMappingURL=@bowencool_vhooks.js.map
